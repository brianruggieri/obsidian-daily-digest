#!/usr/bin/env tsx
/**
 * Generate docs/settings-reference.md from the settings registry.
 *
 * Usage (from project root):
 *   npm run docs:generate
 *
 * The generated file is committed and checked for freshness in CI.
 */

import * as fs from "node:fs";
import * as path from "node:path";
import { fileURLToPath } from "node:url";
import { SETTINGS_REGISTRY, type SettingMeta, type SettingSection } from "../src/settings-registry";

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const ROOT = path.resolve(__dirname, "..");
const OUTPUT_PATH = path.join(ROOT, "docs", "settings-reference.md");

const SECTION_ORDER: SettingSection[] = [
	"General",
	"Data sources",
	"Privacy",
	"AI summarization",
	"Advanced",
	"Meta",
];

const SECTION_ICONS: Record<SettingSection, string> = {
	"General": "‚öôÔ∏è",
	"Data sources": "üóÑÔ∏è",
	"Privacy": "üõ°Ô∏è",
	"AI summarization": "‚ú®",
	"Advanced": "üß†",
	"Meta": "üîß",
};

function formatDefault(meta: SettingMeta): string {
	if (meta.defaultValue === "true") return "`true`";
	if (meta.defaultValue === "false") return "`false`";
	if (meta.defaultValue === "") return "*(empty)*";
	if (meta.defaultValue === "[]") return "`[]`";
	return `\`${meta.defaultValue}\``;
}

function formatType(meta: SettingMeta): string {
	switch (meta.type) {
	case "boolean": return "Toggle";
	case "string": return "Text";
	case "number": return "Number";
	case "select": return "Dropdown";
	case "textarea": return "Text area";
	case "slider": return "Slider";
	case "internal": return "Internal";
	default: return meta.type;
	}
}

function buildSection(section: SettingSection, entries: SettingMeta[]): string {
	const icon = SECTION_ICONS[section];
	const lines: string[] = [];
	lines.push(`## ${icon} ${section}`);
	lines.push("");

	for (const meta of entries) {
		lines.push(`### \`${meta.key}\``);
		lines.push("");
		lines.push(`**${meta.label}**`);
		lines.push("");
		lines.push(meta.description);
		lines.push("");

		const attrs: string[] = [];
		attrs.push(`- **Type:** ${formatType(meta)}`);
		attrs.push(`- **Default:** ${formatDefault(meta)}`);
		if (meta.enabledByDefault) {
			attrs.push("- **On by default:** yes");
		}
		if (meta.dependsOn) {
			attrs.push(`- **Visible when:** \`${meta.dependsOn}\` is enabled`);
		}
		if (meta.privacyNote) {
			attrs.push(`- **Privacy:** ${meta.privacyNote}`);
		}
		lines.push(...attrs);
		lines.push("");
	}

	return lines.join("\n");
}

function generate(): string {
	const grouped = new Map<SettingSection, SettingMeta[]>();
	for (const section of SECTION_ORDER) {
		grouped.set(section, []);
	}
	for (const meta of SETTINGS_REGISTRY) {
		const bucket = grouped.get(meta.section);
		if (bucket) {
			bucket.push(meta);
		}
	}

	const parts: string[] = [];

	parts.push("# Settings Reference");
	parts.push("");
	parts.push(
		"> **Auto-generated** from `src/settings-registry.ts`. " +
		"Do not edit this file directly ‚Äî run `npm run docs:generate` to regenerate."
	);
	parts.push("");
	parts.push("This document describes every setting in the Daily Digest plugin, " +
		"grouped by the settings panel section in which they appear.");
	parts.push("");

	// Table of contents
	parts.push("## Table of Contents");
	parts.push("");
	for (const section of SECTION_ORDER) {
		const icon = SECTION_ICONS[section];
		const anchor = section.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/-+$/, "");
		const count = grouped.get(section)?.length ?? 0;
		parts.push(`- [${icon} ${section}](#${anchor}) (${count} settings)`);
	}
	parts.push("");

	// Sections
	for (const section of SECTION_ORDER) {
		const entries = grouped.get(section) ?? [];
		if (entries.length > 0) {
			parts.push(buildSection(section, entries));
		}
	}

	// Trailing newline
	return parts.join("\n") + "\n";
}

const content = generate();
fs.mkdirSync(path.dirname(OUTPUT_PATH), { recursive: true });
fs.writeFileSync(OUTPUT_PATH, content, "utf8");
console.log(`Generated ${path.relative(ROOT, OUTPUT_PATH)} (${SETTINGS_REGISTRY.length} settings)`);
