#!/usr/bin/env node
/* eslint-disable no-console */

/**
 * Generate Release Validation Section
 *
 * Reads matrix validation report and generates a Markdown section
 * suitable for inclusion in release notes (CHANGELOG.md, GitHub Releases)
 */

import { readFileSync } from "fs";
import { join } from "path";

interface ValidationResult {
  provider: string;
  persona: string;
  quality: number;
  cost: number;
  privacy: { leaks: number; compliant: boolean };
}

interface ValidationReport {
  generated: string;
  phase: number;
  tier: string;
  results: ValidationResult[];
}

function generateReleaseSection(reportPath: string): string {
  let report: ValidationReport;

  try {
    const reportJson = readFileSync(reportPath, "utf-8");
    report = JSON.parse(reportJson);
  } catch (error) {
    return `<!-- No validation data available -->`;
  }

  const lines: string[] = [];

  // Header
  lines.push("## Validation Report\n");
  lines.push(`Generated: ${report.generated}\n`);

  // Quality metrics
  const avgQuality = (
    report.results.reduce((sum, r) => sum + (r.quality || 0), 0) / (report.results.length || 1)
  ).toFixed(0);

  lines.push("### Quality Metrics\n");
  lines.push(`- **Average Quality:** ${avgQuality}%`);
  lines.push("- **Personas Tested:** 6 (Engineer, Researcher, DevOps, PM, Student, Scattered)");
  lines.push("- **Privacy Tiers:** 4 (Standard, RAG, Classified, Deidentified)\n");

  // Provider comparison
  const providers = new Map<string, number[]>();
  for (const result of report.results) {
    if (!providers.has(result.provider)) {
      providers.set(result.provider, []);
    }
    providers.get(result.provider)!.push(result.quality);
  }

  lines.push("### Provider Comparison\n");
  lines.push("| Provider | Avg Quality | Cost/Day |\n");
  lines.push("|----------|-------------|----------|\n");

  let totalCost = 0;
  for (const [provider, qualities] of providers) {
    const avgProviderQuality = (
      qualities.reduce((a, b) => a + b, 0) / qualities.length * 100
    ).toFixed(0);
    const providerCost = report.results
      .filter(r => r.provider === provider)
      .reduce((sum, r) => sum + (r.cost || 0), 0);
    totalCost += providerCost;

    const costStr = providerCost > 0 ? `$${providerCost.toFixed(4)}` : "$0.00";
    lines.push(`| ${provider} | ${avgProviderQuality}% | ${costStr} |\n`);
  }

  // Privacy compliance
  const hasLeaks = report.results.some(r => r.privacy.leaks > 0);
  const allCompliant = report.results.every(r => r.privacy.compliant);

  lines.push("### Privacy & Compliance\n");
  lines.push(allCompliant
    ? `- ✅ **All privacy tiers compliant** — Safe for production\n`
    : `- ❌ **Privacy violations detected** — Review before release\n`
  );
  lines.push(
    hasLeaks
      ? `- ${report.results.filter(r => r.privacy.leaks > 0).length} tier(s) with detected leaks\n`
      : `- ✓ No privacy leaks detected\n`
  );

  // Decision
  lines.push("### Release Decision\n");
  if (allCompliant && avgQuality >= 85) {
    lines.push("✅ **Approved for release** — All quality and privacy gates passed.\n");
  } else if (allCompliant && avgQuality >= 75) {
    lines.push("⚠️ **Approved with review** — Privacy passed but quality is moderate. Monitor user feedback.\n");
  } else {
    lines.push("❌ **Blocked** — Quality or privacy issues detected. Address before release.\n");
  }

  // Cost projection
  lines.push("### Cost Projections\n");
  const dailyCost = totalCost;
  const monthlyCost = dailyCost * 30;
  const annualCost = dailyCost * 365;

  lines.push(`- Daily: $${dailyCost.toFixed(4)}`);
  lines.push(`- Monthly: $${monthlyCost.toFixed(2)}`);
  lines.push(`- Annual: $${annualCost.toFixed(2)}\n`);

  // Testing scope
  lines.push("### Testing Scope\n");
  lines.push(`- **Providers Tested:** ${[...providers.keys()].join(", ")}`);
  lines.push(`- **Test Cases:** ${report.results.length}`);
  lines.push(`- **Tiers Validated:** ${report.tier}\n`);

  // CTA
  lines.push("---\n");
  lines.push("_Validation metrics generated by [Matrix Validator](./docs/matrix-validation/README.md)_\n");

  return lines.join("\n").trim();
}

/**
 * Main execution
 */
const args = process.argv.slice(2);
const reportPath = args[0]
  ? args[0]
  : join(process.cwd(), "results", "matrix-validation-latest.json");

const section = generateReleaseSection(reportPath);
console.log(section);
